"""
希尔排序：
    是对插入排序的升级的版本。(插入排序： 每次拿一个数在前面有序的数列中找到位置进行插入 )
    设置一个步长，一般为数列长度的一半。
    把数列按照步长分组，每组相同位置的数据进行选择排序，
    然后再把步长减小后分组，每组的相同位置元素进行选择排序
    一直步长减小到1位置，进行选择排序
    此时，数列顺序就排好了
"""


def shellsort(input_list):
    if len(input_list)<=1:
        return input_list

    gap=len(input_list)//2
    while gap>0:
        for i in range(gap,len(input_list)):
            tem=input_list[i]
            j=i-gap
            while j>=0 and tem<input_list[j]:
                input_list[j+gap]=input_list[j]
                j-=gap
            input_list[j+gap]=tem
        gap//=2
    print(input_list)

a=[50,123,543,187,49,30,0,2,11,100]
shellsort(a)
print(a)

"""
1、时间复杂度
步长的选择是希尔排序的重要部分，只要最终步长为1任何步长序列都可以工作。
算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。
当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。
步长序列的不同，会导致最坏的时间复杂度情况的不同。
本文中，以N/2为步长的最坏时间复杂度为N^2。
Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N^2)类的算法（插入排序）更好，
但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。
比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样
那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。
用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。
2、算法稳定性
希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。
3、直接插入排序和希尔排序的比较
直接插入排序是稳定的；而希尔排序是不稳定的。
直接插入排序更适合于原始记录基本有序的集合。
希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。    
直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。

"""