'''
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
当指数为负数的时候，可以先对指数求绝对值，然后算出次方的结果之后再取倒数。如果底数为0，则直接返回0。此时的次方在数学上是没有意义的。
'''
class Solution:
    def Power(self, base, exponent):
        if base==0:
            return False
        flag=0
        result=1
        if exponent<0:
            flag=1
        for i in range(abs(exponent)):
            result*=base
        if flag==1:
            return 1/result
        else:
            return result


'''
使用快速幂算法
详细见链接：https://blog.csdn.net/qq_19782019/article/details/85621386

快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，
需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。
这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。

3^10=3*3*3*3*3*3*3*3*3*3//尽量想办法把指数变小来，这里的指数为10
3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)
3^10=(3*3)^5
3^10=9^5
//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。
//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5
9^5=（9^4）*（9^1）
//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作
9^5=（81^2）*(9^1)
//把指数缩小一半，底数执行平方操作
9^5=（6561^1）*(9^1)
//此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。
9^5=（6561^0）*(9^1)*(6561^1)=1*(9^1)*(6561^1)=(9^1)*(6561^1)=9*6561=59049
我们能够发现，最后的结果是9*6561，而9是怎么产生的？是不是当指数为奇数5时，此时底数为9。那6561又是怎么产生的呢？是不是当指数为奇数1时，此时的底数为6561。所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。
'''
#简洁版
def power(base,exponent):
    if base==0:
        return False
    if exponent==0:
        return 1
    res=1
    tmp=abs(exponent)
    while tmp:
        if tmp%2==0:#指数为偶数
            tmp=tmp/2#指数缩减一半
            base=base*base#底数变大成原来的平方
        else:
            tmp-=1#把指数减去1，使其变成一个偶数
            res=res*base#此时记得要把指数为奇数时分离出来的底数的一次方收集好
            tmp=tmp/2#此时指数为偶数，可以继续执行操作
            base=base*base
    return res
print(power(2,6))


#改进
'''
tmp=tmp/2
base=base*base
换成 power = power / 2;
'''
class Solution2:
    def Power(self, base, exponent):
        # write code here
        if base==0:
            return False
        if exponent==0:
            return 1
        res=1
        tmp=abs(exponent)
        while tmp:
            if tmp&1:
                res*=base
            tmp >>=1
            base*=base
        return res if exponent>0 else 1/res