#模板
'''
首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。
比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。
像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。
如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，
把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……
'''

def find(root):#查找根节点
    son=root
    while root!=pre[root]:#寻找根节点
        root=pre[root]
    while son!=root:#路径压缩
        tmp=pre[son]
        pre[son]=root
        son=tmp
    return root
def join(root1,root2):
    x=find(root1)
    y=find(root2)
    if x!=y:#如果不连通，就把他们所在的连通分支合并
        pre[x]=y
'''
某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。
省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。
问最少还需要建设多少条道路？ 

测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 
注意:两个城市之间可以有多条道路相通,也就是说
3 3
1 2
1 2
2 1
这种输入也是合法的
当N为0时，输入结束，该用例不被处理。

对每个测试用例，在1行里输出最少还需要建设的道路数目。 
'''
n,m=list(map(int,input().split()))
pre=[0]*(n+1)#存放第i个元素的父节点
total=n-1#共有n-1个门派
for i in range(1,n+1,1):#初始化并查集表
    pre[i]=i
total=n-1#共有num-1个门派
while m:
    start,end=list(map(int,list(input().split())))
    # end=list(map(int,list(input().split())))
    root1=find(start)
    root2=find(end)
    if root1!=root2:#掌门不同，踢馆
        pre[root1]=root2
        total-=1#门派少一个，敌人就少一个
    m-=1
print(total)



