'''
给定一个无序的整数数组，找到其中最长上升子序列的长度。
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
'''
'''
思路：参考大佬的 
方法一：动态规划
“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。
有的资料又将“动态规划”分为 3 步：
base case：思考问题规模最小的时候，是什么情况；
update function：自下而上思考这个问题，即上面的“状态转移方程”；
gola：重点强调了输出是什么，很多时候输出并不一定是最后一个状态。
我觉得这种分法更细致一点，“状态”以及“状态转移方程”也没有问题，但是我觉得还要加上一个，思考一下“输出”是什么，
即将第 2 种的第 3 步加上去，在下面的分析中，我还会强调这一点。
1、定义状态
首先我们考虑能否将题目的问法定义成状态，即 dp[i] 表示长度为 i 的最长上升子序列的长度，但仔细思考之后，我们发现：由于“子序列”不要求连续，
长度为 i - 1 的最长上升子序列，与长度为 i 的“最长上升子序列之间的递推关系并不那么容易得到。
但我们由「力扣」第 3 题：“无重复字符的最长子串”以及「力扣」第 53 题：“最大子序和”这两个问题的经验，再结合题意，可以知道，“上升”的递推关系是：
看子序列最后一个数，如果一个新数，比子序列最后一个数还大，那么就可以放在这个子序列的最后，形成一个更长的子序列。反正一个子序列一定会以一个数字结尾，
那我就将状态成以 nums[i] 结尾的“最长上升子序列”的长度，这一点是常见的。
dp[i]：表示以第 i 个数字为结尾的“最长上升子序列”的长度。即在 [0, ..., i] 的范围内，选择 以数字 nums[i] 结尾 可以获得的最长上升子序列的长度。
注意：以第 i 个数字为结尾，即 要求 nums[i] 必须被选取。
初始化的时候，因为每个元素自己可以认为是一个长度为 1 的子序列，所以可以将 dp 数组的值全部设置为 11。
定义输出：下面要考虑一下输出，由于状态不是题目中的问法，因此不能将最后一个状态作为输出，这里输出是把 dp[0]、dp[1]、……、dp[n - 1] 全部看一遍，取最大值。

2、推导“状态转移方程”
遍历到索引是 i 的数的时候，根据上面“状态”的定义，考虑把 i 之前的所有的数都看一遍，只要当前的数 nums[i] 严格大于之前的某个数，
那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列。因此，dp[i] 就是之前严格小于 nums[i] 的“状态”最大值加 1。
因此，状态转移方程是：
dp[i] = max{1 + dp[j] for j < i if nums[j] < nums[i]}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/two-sum/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
'''
def lengthLTS(nums):
    size=len(nums)
    if size<2:
        return size
    dp=[1]*size
    for i in range(1,size):
        for j in range(i):
            if nums[i]>nums[j]:
                dp[i]=max(dp[i],dp[j]+1)
    return max(dp)
'''
复杂度分析：
时间复杂度：O(N^2)因为有两个 for 循环，每个 for 循环的时间复杂度都是线性的。
空间复杂度：O(N)，要开和数组等长的状态数组，最后要拉通看一遍状态数组的最大值，因此空间复杂度是 O(N)
'''

'''
贪心算法和二分查找
算法的基本思想：
如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。
这个思想并不难理解，我们举例说明：如果前面的数是 11，后面接上一个随机数，能够构成长度为 2 的“上升子序列”的可能性，
就远远大于前面的数是 10000，后面接上一个随机数，能够构成长度为 22 的“上升子序列”的可能性。

算法的执行流程：
1、设置一个有序数组 tail，初始时为空；
数组命名为 tail 即 PPT 中各个行表示的数组（是一个“上升子序列”）的结尾，注意：有序数组 tail 虽然有“上升”的性质，但它不是每时每刻都表示问题中的“最长上升子序列”（下文还会强调），不能命名为 LIS，有序数组 tail 是用于求解 LIS 问题的辅助数组。
2、在遍历数组 nums 的过程中，每来一个新数 num，如果这个数严格大于有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 3 点；
注意：这里的大于是“严格”大于，不包括等于的情况。
3、在有序数组 tail 中查找第 1 个等于大于 num 的那个数，试图让它变小；
如果有序数组 tail 中存在等于 num 的元素，什么都不做，因为以 num 结尾的最短的“上升子序列”已经存在；
如果有序数组 tail 中存在大于 num 的元素，找到第 1 个，让它变小，这样我们就找到了一个“结尾更小”的“相同长度”的上升子序列。
这一步可以使用“二分查找法”。
4、遍历新的数 num ，先尝试上述第 2 点，第 2 点行不通则执行第 3 点，直到遍历完整个数组 nums，最终有序数组 tail 的长度，就是所求的“最长上升子序列”的长度。
算法的关键之处：
以上算法能够奏效的关键是：
最开始提到的“基本思想”，可以认为是一种“贪心选择”的思想：只要让前面的数尽量小，在算法的执行过程中，第 2 点被执行的机会就越多。
下面从算法运行的角度看一个具体的例子，此时我们使用的辅助数组是一维的，以便于您理解算法的基本思想和执行流程。
以下 2 点注意事项，请读者结合示例认真体会。
注意事项：
1、虽然有序数组 tail 是升序数组，但是这个数组并不是每时每刻都表示题目要求的那个“最长上升子序列”，这一点你可以在我上面的例子中找到例证；
有序数组 tail 可以这样理解：
tail[i] 表示长度为 i + 1 （因为 i 表示索引，i + 1 表示长度）的所有“上升子序列”里结尾最小的元素。
因此， 有序数组 tail 的长度就是题目所求的“最长上升子序列”的长度。
2、“贪心选择性质”保证了算法流程的第 2 点有更多机会被执行。
'''
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        # 特判
        if size < 2:
            return size

        # 为了防止后序逻辑发生数组索引越界，先把第 1 个数放进去
        tail = [nums[0]]
        for i in range(1, size):
            # 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大
            # 先尝试是否可以接在末尾
            if nums[i] > tail[-1]:
                tail.append(nums[i])
                continue

            # 使用二分查找法，在有序数组 tail 中
            # 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
            left = 0
            right = len(tail) - 1
            while left < right:
                # 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解
                # mid = left + (right - left) // 2
                mid = (left + right) >> 1
                if tail[mid] < nums[i]:
                    # 中位数肯定不是要找的数，把它写在分支的前面
                    left = mid + 1
                else:
                    right = mid
            # 走到这里是因为【逻辑 1】的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素，因此无需再单独判断
            tail[left] = nums[i]
        return len(tail)
